#!/usr/bin/python3

import os
import shutil
import json
import argparse

# Helper functions
def prompt_yes_no(msg, automatic_yes=False, ask_twice=False):

    assert type(automatic_yes) is bool
    assert type(ask_twice) is bool

    if automatic_yes:
        return True
    else: 
        YES_ANSWERS = ['y', 'Y']
        if ask_twice:
            return (input(msg + " [yY/nN]: ") in YES_ANSWERS and
                input("Are you sure? [yY/nN]: ") in YES_ANSWERS)
        else:
            return input(msg + " [yY/nN]: ") in YES_ANSWERS

def pathlink_link(original_dir, destination_dir, tracked_paths, execute_linking, automatic_yes):

    for tracked_path in tracked_paths:

        original_path = os.path.join(original_dir, tracked_path)
        destination_path = os.path.join(destination_dir, tracked_path)

        print(f"### Processing dir {tracked_path} ###")

        if os.path.exists(destination_path):
            if not os.path.exists(original_path) and not os.path.islink(original_path):
                if execute_linking and prompt_yes_no("original_dir: Link doesn't exist. Do you want to add?", automatic_yes=automatic_yes):
                    os.symlink(destination_path, original_path)
            elif os.path.islink(original_path):
                if os.readlink(original_path) == destination_path:
                    print(f"original_dir: Symbolic link {original_path} already points to correct location")
                else:
                    if execute_linking and prompt_yes_no(f"original_dir: Symbolic link {original_path} points to other location: {os.readlink(original_path)}. Do you want to overwrite it?"
                            , automatic_yes=automatic_yes, ask_twice=True):
                        os.unlink(original_path)
                        os.symlink(destination_path, original_path)
            elif os.path.isdir(original_path):
                if execute_linking and prompt_yes_no(f"original_dir: Folder {original_path} already exists. Do you want to overwrite it?"
                        , automatic_yes=automatic_yes, ask_twice=True):
                    shutil.rmtree(original_path)
                    os.symlink(destination_path, original_path)
            else: # should be a file
                if execute_linking and prompt_yes_no(f"original_dir: File {original_path} already exists. Do you want to overwrite it?"
                        , automatic_yes=automatic_yes, ask_twice=True):
                    os.remove(original_path)
                    os.symlink(destination_path, original_path)
        else: # backup path doesn't exist
            if not os.path.exists(original_path) and not os.path.islink(original_path):
                print("original and destination paths don't exist.")
            elif os.path.islink(original_path):
                print("original path is a link. no destination path.")
            else: # original path is a file/dir 
                if execute_linking and prompt_yes_no("original_dir: File/folder exists. Do you want to move it to destination and link it?", automatic_yes=automatic_yes):
                    # Move original to backup location
                    backup_path_folder = os.path.abspath(os.path.join(destination_path, '..'))
                    shutil.move(original_path, backup_path_folder)
                    # Create symlink
                    os.symlink(destination_path, original_path)
                else:
                    print("Ok. DIY")

def pathlink_unlink(original_dir, destination_dir, tracked_paths, execute_linking, automatic_yes):

    for tracked_path in tracked_paths:

        original_path = os.path.join(original_dir, tracked_path)
        destination_path = os.path.join(destination_dir, tracked_path)

        print(f"### Processing dir {tracked_path} ###")

        if (os.path.islink(original_path) 
            and os.readlink(original_path) == destination_path
            and os.path.exists(destination_path)):
            if execute_linking and prompt_yes_no("Do you want to remove the link?", automatic_yes=automatic_yes):
                os.unlink(original_path)
                shutil.move(destination_path, original_path)
        else:
            print('Not a proper link. DIY')


def pathlink(settings_path, mode='link', execute_linking=True, automatic_yes=False):

    assert type(execute_linking) is bool
    assert type(automatic_yes) is bool
    assert type(mode) is str

    with open(settings_path, 'r') as f:
        settings = json.load(f)

    tracked_paths = settings['tracked_paths']
    original_dir = settings['original_dir']
    destination_dir = settings['destination_dir']

    assert type(tracked_paths) is list, "tracked_paths is not a list"
    assert tracked_paths, "tracked_paths is empty"
    assert isinstance(original_dir, str) and os.path.isdir(original_dir), "original_dir is not a directory"
    assert isinstance(destination_dir, str) and os.path.isdir(destination_dir), "destination_dir is not a directory"
    assert mode == 'link' or mode == 'unlink', f'invalid mode: {mode}'

    if mode == 'link':
        pathlink_link(original_dir, destination_dir, tracked_paths, execute_linking, automatic_yes)
    elif mode == 'unlink':
        pathlink_unlink(original_dir, destination_dir, tracked_paths, execute_linking, automatic_yes)


if __name__ == "__main__":

    # Parse script arguments
    parser = argparse.ArgumentParser()

    parser.add_argument('-m', '--mode', type=str, default='link', choices=['link', 'unlink'],
        help='chooses mode for execution: link (add symbolic links), unlink (remove symbolic links)')
    parser.add_argument('-d', '--dry-run', action='store_true',
        help='just print info without any action')
    parser.add_argument('--id', type=str, default='*',
        help='specifies which folders from config to link (default: * (all ids))')
    # default settings json file
    SETTINGS_JSON = os.path.join(os.path.expanduser('~'), '.pathlinker.json')
    parser.add_argument('-s', '--settings-json', type=str, default=SETTINGS_JSON,
        help='specifies file with settings (default: ~/.pathlinker.json)')

    args = parser.parse_args()

    assert os.path.isfile(args.settings_json), '--settings-file should be a proper file'

    pathlink(args.settings_json, mode=args.mode, execute_linking=not args.dry_run)

